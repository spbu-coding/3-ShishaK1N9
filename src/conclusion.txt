Суть эксперимента: выяснить, что происходит с точностью чисел с плавающей точкой в C, пользуясь двумя типами данных(float, double).
Для выяснения использовалась система уравнений:

x + y = 2;
x + 1.0001 * y = 2.0001 + delta.

Эталонным решением, с которым сравнивались все последующие, считали пару (1, 1), при delta = 0.
Для получения новых решений и вычисления нормы на каждой итерации уменьшали дельту в 2 раза, до тех пор пока норма не станет меньше фиксированного эпсилон, либо дельта станет меньше другого фиксированного эпсилон(что означает промахи в точности).

Суммарно было проведено 4 опыта(по 2 с каждым типом данных). Разберем каждый из них:
1.float_successful.
	Опыт не завершился ошибкой, потому что в какой-то норма стала меньше фиксированного эпсилон и при небольшом смещении (delta = 0.0000781) был получен максимально блиэкий ответ с нормой равной 0.0110472.
	Но его нельзя считать успешным, потому что эпсилон было слишком большим (0.01), что является слишком большим числом по сравнению с нормой и дельтой, т.е. полученной точности недостаточно для более точных вычислений.
	В этом можно убедиться, посмотрев на второй опыт.
2.float_unsuccessful.
	Данный опыт как и предыдущий проводился в типе данных float, но завершился ошибкой. Почему же так произошло? Отличие этого опыта от предущего заключается в том, что упсилон была взята в 10000 раз меньше, что должно было повысить точность, но к сожалению float не дает столь высокой точности, из-за чего дельта стала меньше эпсилон раньше, чем норма стала меньше другого эпсилон.
	Таким образом, для хранения достаточно точных значений и проведения с ними вычислений float использовать не стоит.

Посмотрим, что происходит в этом эксперименте, если воспользоваться типом данных double.
3.double_successful.
	Из названия можно понять, что опыт закончился успешно. При delta = 0.000001 (как во втором опыте) норма (0.000001348702137) в какой-то момент стала меньше эпсилон. Это говорит о том, что для хранения более точных значения стоит выбрать double нежели float.
	Но в какой момент double даст сбой.
4.double_unsuccessful.
	При эпсилон равном 0.0000000001 дельта стала меньше другого эпсилон раньше, чем норма меньше эпсилон. Но говорит ли это о том, что double неточный? Посмотрев на количество знаков после запятой во всех числовых переменных и в (x, y) можно заметить, что точность выше чем во float.
	
Можно ли считать эксперимент корректным?
Учитывая, что точность вычислений зависит от способа вычисления, от выбранных эпсилон (для сравнения дельта и для сравнения нормы), нельзя говорить о том, что эксперимент корректный. Т.к. из опытов можно было заметить, что изменив одну из эпсилон, точность может возрасти, либо же уменьшиться. Не говоря уже об изменении способа вычисления. Если для вычисления y не делить а умножать, точность заметно вырастет.
Таким образом по данному эксперименту можно судить о точности типов данных только в фиксированной системе, где можно считать только одним способом и эпсилон могут быть только одни.